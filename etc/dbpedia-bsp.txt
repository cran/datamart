http://www.snee.com/bobdc.blog/2009/07/court-decision-metadata-and-db.html
SELECT DISTINCT ?s WHERE {
  ?s 
  <http://www.w3.org/2004/02/skos/core#subject>
  <http://dbpedia.org/resource/Category:United_States_Supreme_Court_cases>
}
Even better, I noticed at the bottom of the Wikipedia page for Campbell v Acuff-Rose that it belonged to the Wikipedia category US copyright case law, a pretty important bit of categorization metadata. Sure, you can look at that page to see the list, but you can also retrieve the list with a slight modification to the SPARQL query above:

SELECT DISTINCT ?s WHERE {
  ?s 
  <http://www.w3.org/2004/02/skos/core#subject>
  <http://dbpedia.org/resource/Category:United_States_copyright_case_law>
}

http://blogs.kde.org/node/3576
A query for all articles with an image:
SELECT ?a, ?b WHERE {
?a foaf:img ?b
}

A list of all drugs:
SELECT ?a WHERE {
?a skos:subject
}

Everything with an LGPL license:
SELECT ?a WHERE {
?a dbpedia2:license "LGPL"@en
}

All translations of 'Chair':
SELECT ?a WHERE {
:Chair rdfs:label ?a
}

All carnivors that had their name stolen:
SELECT ?a, ?b WHERE {
?a dbpedia2:disambiguates ?b .
?a dbpedia2:regnum :Animal
}

All married kernel hackers:
SELECT ?a, ?b WHERE {
?a skos:subject .
?a dbpedia2:spouse ?b
}

All pages that redirect to a plant:
SELECT ?a, ?b WHERE {
?a dbpedia2:redirect ?b .
?b dbpedia2:regnum :Plant
}

A query for all green plants:
SELECT ?a WHERE {
?a dbpedia2:regnum :Plant .
?a dbpedia2:color "green"@en
}

http://lists.w3.org/Archives/Public/public-sparql-dev/2008JulSep/0038.html
I quite like this one:

PREFIX geo: <http://www.geonames.org/ontology#>
PREFIX wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
SELECT DISTINCT ?an ?lat ?long ?name ?population
WHERE
{ ?a
     a mo:MusicArtist;
     foaf:based_near ?place;
     foaf:name ?an;
     foaf:made ?alb.
  ?alb tags:taggedWithTag <http://dbtune.org/jamendo/tag/punk>.
  ?place
     geo:name ?name;
     geo:population ?population;
     wgs:lat ?lat;
     wgs:long ?long }
ORDER BY ?population

on http://dbtune.org/jamendo/ (order me bands that have been tagged as
`punk' by a Jamendo user by the number of inhabitants in their city)

Or that one:

SELECT ?brand ?title ?count
WHERE {
   ?artist a mo:MusicArtist;
      foaf:name "The Beatles".
   ?pc pc:object ?artist;
       pc:count ?count.
   ?brand a po:Brand;
       pc:playcount ?pc;
       dc:title ?title
    FILTER (?count>10)}

on http://dbtune.org/bbc/playcount/ (give me BBC shows on which the
Beatles have been featured more than 10 times)

Or that one:

PREFIX af: <http://purl.org/ontology/af/>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX tl: <http://purl.org/NET/c4dm/timeline.owl#>

SELECT ?start ?duration
FROM <http://dbtune.org/echonest/analyze-example.rdf>
WHERE
{
?e      a af:StructuralSegment;
        event:time ?time.
?time   tl:start ?start;
        tl:duration ?duration.
}

Using the GRDDL'ed results of the Echonest Analyse API, and getting
structural segments (eg. chorus, verse, etc.) on a particular track.

And finally, this one:

PREFIX void: <http://purl.org/ontology/void#>
PREFIX mo: <http://purl.org/ontology/mo/>
PREFIX tags: <http://www.holygoat.co.uk/owl/redwood/0.1/tags/>

ASK
FROM NAMED <http://moustaki.org/void/void.n3>
FROM NAMED <http://moustaki.org/void/jamendo_example.n3>
{
        GRAPH <http://moustaki.org/void/void.n3> {
                ?ds a void:Dataset;
                        void:sparql_end_point ?sparql;
                        void:example ?ex.
        }
        GRAPH ?ex {
                ?r a mo:Record;
                        mo:available_as ?l;
                        tags:taggedWithTag ?t.
        }
}

Which is explained in more details at
http://blog.dbtune.org/post/2008/06/12/Describing-the-content-of-RDF-datasets


http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com's%20BLOG%20%5B127%5D/1372
-- Find all Fiction Books associated with a property "dbpedia:name" that has literal value:  "The Lord of the Rings" .

DEFINE input:inference "http://dbpedia.org/resource/inference/rules/yago#"

PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

PREFIX dbpedia: &lt;http://dbpedia.org/property&gt;

PREFIX yago: &lt;http://dbpedia.org/class/yago&gt;&nbsp;


SELECT DISTINCT  ?s
FROM < xmlns="http" dbpedia.org="dbpedia.org">//dbpedia.org>
WHERE {
?s a yago:Fiction106367107 .
?s dbpedia:name "The Lord of the Rings"@en .
}
-- Variant of query with Virtuoso's Full Text Index extension via the bif:contains function/magic predicate

DEFINE input:inference "http://dbpedia.org/resource/inference/rules/yago#"

PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

PREFIX dbpedia: &lt;http://dbpedia.org/property&gt;

PREFIX yago: &lt;http://dbpedia.org/class/yago&gt;&nbsp;

SELECT DISTINCT ?s ?n

FROM < xmlns="http" dbpedia.org="dbpedia.org">//dbpedia.org>

WHERE {

?s a yago:Fiction106367107 .

?s dbpedia:name ?n .

?n bif:contains 'Lord and Rings'

}

-- Retrieve all individuals instances of Fiction Class which should include all Books.

DEFINE input:inference "http://dbpedia.org/resource/inference/rules/yago#"

PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

PREFIX dbpedia: &lt;http://dbpedia.org/property&gt;

PREFIX yago: &lt;http://dbpedia.org/class/yago&gt;&nbsp;

SELECT DISTINCT ?s
FROM < xmlns="http" dbpedia.org="dbpedia.org">//dbpedia.org>
WHERE {
?s a yago:Fiction106367107 .
} LIMIT 50
Note: you can also m

http://www.w3.org/2009/Talks/0615-qbe/
Dataset: DBPedia

DBPedia is an RDF version of information from Wikipedia.
DBPedia contains data derived from Wikipedia's infoboxes, category hierarchy, article abstracts, and various external links.
DBpedia contains over 100 million triples.
Query #4: Exploring DBPedia

Find me 50 example concepts in the DBPedia dataset.
SELECT DISTINCT ?concept
WHERE {
    ?s a ?concept .
} LIMIT 50
        
LIMIT is a solution modifier that limits the number of rows returned from a query. SPARQL has two other solution modifiers:
ORDER BY for sorting query solutions on the value of one or more variables
OFFSET, used in conjunction with LIMIT and ORDER BY to take a slice of a sorted solution set (e.g. for paging)
The SPARQL keyword a is a shortcut for the common predicate rdf:type, giving the class of a resource.
The DISTINCT modifier eliminates duplicate rows from the query results.
Try it with a DBPedia-specific SPARQL endpoint. (Expected results.)

Query #5: Basic SPARQL filters

Find me all landlocked countries with a population greater than 15 million.
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>        
PREFIX type: <http://dbpedia.org/class/yago/>
PREFIX prop: <http://dbpedia.org/property/>
SELECT ?country_name ?population
WHERE {
    ?country a type:LandlockedCountries ;
             rdfs:label ?country_name ;
             prop:populationEstimate ?population .
    FILTER (?population > 15000000) .
}
        
FILTER constraints use boolean conditions to filter out unwanted query results.
Shortcut: a semicolon (;) can be used to separate two triple patterns that share the same subject. (?country is the shared subject above.)
rdfs:label is a common predicate for giving a human-friendly label to a resource.
Note all the translated duplicates in the results. How can we deal with that?

Query #6: Filters for picking among translations

Find me all landlocked countries with a population greater than 15 million (revisited), with the highest population country first.
PREFIX type: <http://dbpedia.org/class/yago/>
PREFIX prop: <http://dbpedia.org/property/>
SELECT ?country_name ?population
WHERE {
    ?country a type:LandlockedCountries ;
             rdfs:label ?country_name ;
             prop:populationEstimate ?population .
    FILTER (?population > 15000000 && langMatches(lang(?country_name), "EN")) .
} ORDER BY DESC(?population)
        
lang extracts a literal's language tag, if any
langMatches matches a language tag against a language range
Try it with a DBPedia-specific SPARQL endpoint. (Expected results.)

Query #11: ASKing a question

Is the Amazon river longer than the Nile River?
PREFIX prop: <http://dbpedia.org/property/>
ASK
{
  <http://dbpedia.org/resource/Amazon_River> prop:length ?amazon .
  <http://dbpedia.org/resource/Nile> prop:length ?nile .
  FILTER(?amazon > ?nile) .
}       
        
The ASK result clause simply returns true or false depending on whether or not the query pattern has any matches in the dataset.
As with SELECT queries, the boolean result is (by default) encoded in an SPARQL Results Format XML document.
Shortcut: the WHERE keyword is optional--not only in ASK queries but in all SPARQL queries.

Query #16: SPARQL extension: free-text search

Find me countries with 'Republic' in their name that were established before 1920.
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>        
PREFIX type: <http://dbpedia.org/class/yago/>
PREFIX prop: <http://dbpedia.org/property/>
SELECT ?lbl ?est
WHERE {
  ?country rdfs:label ?lbl .
  FILTER(bif:contains(?lbl, "Republic")) .
  ?country a type:Country108544813 ;
      prop:establishedDate ?est .
  FILTER(?est < "1920-01-01"^^xsd:date) .
}
        
OpenLink's Virtuoso uses an extension filter function, bif:contains to filter literal values against a free-text index. Other implementations use other techniques.
Try it with the Virtuoso DBPedia SPARQL endpoint. (Expected results.)

http://www.snee.com/bobdc.blog/2007/11/querying-dbpedia.html
 SELECT ?season, ?episode,?chalkboard_gag WHERE {
  ?episode skos:subject ?season .
  ?season rdfs:label ?season_title .
  ?episode dbpedia2:blackboard ?chalkboard_gag .
  FILTER (regex(?season_title, "The Simpsons episodes, season")) .
  }
  ORDER BY ?season
  
http://wiki.dbpedia.org/Datasets?v=lbf#h18-7
http://www.lespetitescases.net/semweblabs/dbpedia/